# Лабораторная работа №5: Многопоточность в C++

## Описание реализованных алгоритмов и методов параллелизации

1. **Последовательное размытие (`sequentialBlur`)**
   - Осуществляется проход по всем пикселям изображения.
   - Для каждого пикселя вычисляется средний цвет в окне `k×k` (пример: 3×3), с учётом границ.
   - Выполняется в одном потоке, все операции последовательны.

2. **Параллельное размытие потоками (`parallelBlurThreads`)**
   - Изображение делится по строкам на `numThreads` примерно равных частей.
   - Запускаются `numThreads` потоков, каждый из которых обрабатывает свой диапазон строк.
   - Потоки пишут результат в отдельные части выходного буфера, что исключает гонки данных без мьютексов.

3. **Атомарные операции vs `mutex` (`atomic_example`)**
   - Демонстрация двух подходов к синхронизации инкремента общего счётчика:
     - **С мьютексом**: каждый поток перед операцией `++counter_mutex` захватывает `std::mutex`.
     - **С `std::atomic`**: используется аппаратно-атомарный инкремент без блокировок ОС.


## Результаты сравнения производительности

### Размытие изображения (набор `input.jpg`)

| Вариант                  | Время (ms)    |
|--------------------------|---------------|
| Sequential (`k=3`)       | 84.3034       |
| Parallel (12 потоков)    | 18.4599       |


### Инкремент счётчика

| Вариант                  | Итоговое значение | Время (ms) |
|--------------------------|-------------------|------------|
| Mutex (4 потока)         | 400000000         | 0.0002     |
| Atomic (4 потока)        | 400000000         | 0.0001     |


## Как многопоточность улучшает производительность

- **Параллелизм работы**: каждое ядро CPU обрабатывает свою часть данных, что позволяет сократить общее время выполнения.
- **Независимость задач**: в задаче размытия каждый пиксель (или группа пикселей) можно обрабатывать независимо, что идеально ложится на модель многопоточности.
- **Масштабируемость**: при росте числа ядер время выполнения падает приблизительно обратно пропорционально количеству потоков (с учётом накладных расходов).


## Проблемы синхронизации потоков и способы их решения

1. **Гонки данных (data races)**
   - Возникают, когда несколько потоков одновременно читают/пишут один и тот же ресурс без защиты.

2. **Мьютексы (`std::mutex` / `std::lock_guard`)**
   - Обеспечивают взаимное исключение: только один поток в критической секции.
   - Надёжны для любых блоков кода, но имеют высокие накладные расходы на захват и освобождение, что может снижать производительность.

3. **Атомарные операции (`std::atomic`)**
   - Используют аппаратно-атомарные инструкции, минимизируя накладные расходы.
   - Идеальны для простых операций (счётчики, флаги), но не подходят для комплексных секций с несколькими операциями.

4. **Выбор инструмента**
   - Для простых счётчиков или одноэтапных операций — `std::atomic`.
   - Для сложных и последовательных критических секций — `std::mutex`.

